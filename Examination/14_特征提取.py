"""  小明是一名算法工程师，同时也是一名铲屎官。某天，他突发奇想，想从猫咪的视频里挖掘一些猫咪的运动信息。为了提取运动信息，
他需要从视频的每一帧提取“猫咪特征”。一个猫咪特征是一个两维的vector<x, y>。如果x_1=x_2 and y_1=y_2，那么这俩是同一个特征。
因此，如果喵咪特征连续一致，可以认为喵咪在运动。也就是说，如果特征<a, b>在持续帧里出现，那么它将构成特征运动。比如，
特征<a, b>在第2/3/4/7/8帧出现，那么该特征将形成两个特征运动2-3-4 和7-8。
现在，给定每一帧的特征，特征的数量可能不一样。小明期望能找到最长的特征运动。
输入描述:
第一行包含一个正整数N，代表测试用例的个数。
每个测试用例的第一行包含一个正整数M，代表视频的帧数。
接下来的M行，每行代表一帧。其中，第一个数字是该帧的特征个数，接下来的数字是在特征的取值；比如样例输入第三行里，2代表该帧
有两个猫咪特征，<1，1>和<2，2>
所有用例的输入特征总数和<100000
N满足1≤N≤100000，M满足1≤M≤10000，一帧的特征个数满足 ≤ 10000。
特征取值均为非负整数。
输出描述:
对每一个测试用例，输出特征运动的长度作为一行

输入例子1:
1
8
2 1 1 2 2
2 1 1 1 4
2 1 1 2 2
2 2 2 1 4
0
0
1 1 1
1 1 1
输出例子1:
3
例子说明1:
特征<1,1>在连续的帧中连续出现3次，相比其他特征连续出现的次数大，所以输出3
"""
'''特征连续出现的次数最大：用一个字典pre来记录前一行，遍历下一行的时候 就没有该特征默认次数为0'''


class Frame:
    def longest(self, frames):
        pre, res = {}, 0            # 定义全局变量pre字典，记录前一帧的特征
        for frame in frames:
            cur = {}                # 当前帧的记录字典，每一次循环都会置为空
            for pair in frame:      # 遍历每一帧里面的 猫咪特征
                cnt = 1 + pre.get(pair, 0)      # 如上一帧里 没有该特征，则默认次数为0
                cur[pair] = cnt
                res = max(res, cnt)
            pre = cur               # 将当前帧记录的字典pre，赋给pre，开始下一帧的遍历
        return res


fr = Frame()
n = int(input())
for _ in range(n):
    m = int(input())
    frames = []
    for _ in range(m):
        line = list(map(int, input().split()))
        frames.append([(line[i], line[i + 1]) for i in range(1, len(line), 2)])     # 提取输入，两两一组
    print(fr.longest(frames))
