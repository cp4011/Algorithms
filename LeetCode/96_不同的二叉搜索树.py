"""给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
示例: 输入: 3   输出: 5
解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树:
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
"""
"""用G(n)表示n个结点的不同二叉树数量。用f(i)表示结点数为n时，以i为根结点二叉树的数量。 那么G(n)=f(1)+f(2)……+f(n)。 
而f(i)=G(i-1)G(n-i)——即以i为根结点的二叉树数量等于其左子树个数乘右子树个数。 那么G(n)=G(1)G(n-1)+G(2)G(n-2)……+G(n-1)G(1) 
（） （）式即为卡特兰数的表达式，到此请移步卡兰特数介绍。 这里可直接循环求出： F(n)=F(n-1)(4n-2)/(n+1)
"""


def numTrees(n):            # 卡特兰数的通项是c(2n, n)/(n+1) =  (2n)!/((n+1)!*n!)
    import math             # math.factorial()：阶乘
    return math.factorial(2 * n) // (math.factorial(n+1) * math.factorial(n))   # 注意是地板除，不然返回的是5.0


"""很多现实的问题都是卡特兰数，如合法的入栈出栈序列有多少种就是卡特兰数，为什么呢？我们可以把0看成入栈操作，1看成出栈操作，
即0的累计个数不小于1的排列有多少种。还有很多其他的问题都是卡特兰数，如二叉树的个数，有序树的个数，多边形分成三角形的个数等"""


# DP
def numTrees1(n):
    res = [0] * (n + 1)
    res[0] = 1
    for i in range(1, n + 1):
        for j in range(i):
            res[i] += res[j] * res[i - 1 - j]
    return res[n]
