"""判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。
数字 1-9 在每一行只能出现一次。  数字 1-9 在每一列只能出现一次。  数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
上图是一个部分填充的有效的数独。数独部分空格内已填入了数字，空白格用 '.' 表示。

示例 1:
输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true

示例 2:
输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
说明:
一个有效的数独（部分已被填充）不一定是可解的。只需要根据以上规则，验证已经填入的数字是否有效即可。
给定数独序列只包含数字 1-9 和字符 '.' 。给定数独永远是 9x9 形式的。
"""

'''题意： 9x9数独 每一行、每一列、每一个小正方形都不能重复出现相同数字
    1.  记录它的行，列和小正方形的值，有重复就false
    用一个集合，分别记录行，列，和小正方形！    行,列我们直接可以用数字表示， 
    把小正方形变成用二维唯一标识,比如(0,0)表示左上角那个,(1,1)表示中间那个,他们和行列的关系就是(i//3,j//3)
    2.  改进空间复杂度。只需要用一个集合就可以搞定!  比如我们把board[i][j]用字符串：
    表示行：(i) + board[i][j]   表示列：board[i][j] + (j)   表示小正方形：(i//3) + board[i][j] + (j//3)
'''


class Solution:
    def isValidSudoku(self, board):
        """:type board: List[List[str]]  :rtype: bool   9x9 的数独，验证已经填入的数字是否有效即可 """
        set1 = set()
        for i in range(9):
            for j in range(9):
                if board[i][j].isdigit():       # str.isdigit() 检测字符串是否只由数字组成   例子1中有30个数字，则会set1最后会有90个
                    row = "(" + str(i) + ")" + board[i][j]
                    col = board[i][j] + "(" + str(j) + ")"      # 随便定义的标识符，用于唯一化判断
                    small_square = "(" + str(i // 3) + ")" + board[i][j] + "(" + str(j // 3) + ")"
                    if row in set1 or col in set1 or small_square in set1:
                        return False
                    # 集合添加元素：set.add("cp")；set.update(["cp"，"sp"])也可添加元素，且参数可以是列表，元组，字典
                    set1.update([row, col, small_square])
        return True                 # 注意该行的位置 遍历完81个元素以后，才有return True

    def isValidSudoku1(self, board):
        rows = [{} for i in range(9)]
        columns = [{} for i in range(9)]
        boxes = [{} for i in range(9)]
        # 验证
        for i in range(9):
            for j in range(9):
                num = board[i][j]
                if num != '.':
                    num = int(num)
                    box_index = (i // 3) * 3 + j // 3
                    # keep the current cell value
                    rows[i][num] = rows[i].get(num, 0) + 1
                    columns[j][num] = columns[j].get(num, 0) + 1
                    boxes[box_index][num] = boxes[box_index].get(num, 0) + 1
                    # check if this value has been already seen before
                    if rows[i][num] > 1 or columns[j][num] > 1 or boxes[box_index][num] > 1:
                        return False
        return True


Solution().isValidSudoku([
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
])