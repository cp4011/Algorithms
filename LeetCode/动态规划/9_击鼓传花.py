"""游戏规则是这样的：n个同学坐着围成一个圆圈，指定一个同学手里拿着一束花，主持人在旁边背对着大家开始击鼓，鼓声开始之后
拿着花的同学开始传花，每个同学都可以把花传给自己左右的两个同学中的一个（左右任意），当主持人停止击鼓时，传花停止，此时，
正拿着花没传出去的那个同学就要给大家表演一个节目。
聪明的小赛提出一个有趣的问题：有多少种不同的方法可以使得从小赛手里开始传的花，传了m次以后，又回到小赛手里。对于传递的
方法当且仅当这两种方法中，接到花的同学按接球顺序组成的序列是不同的，才视作两种传花的方法不同。比如有3个同学1号、2号、3号，
并假设小赛为1号，花传了3次回到小赛手里的方式有1->2->3->1和1->3->2->1，共2种。
 输入
输入共一行，有两个用空格隔开的整数n，m（3<=n<=30，1<=m<=30）
样例输入
3 3
输出
输出共一行，有一个整数，表示符合题意的方法数
样例输出
2
 """


n, m = map(int, input().split())
dp = [[0 for i in range(m)] for j in range(n)]
dp[0][0] = 1
dp[2][0] = 1
for i in range(1, m):
    for j in range(n):
          dp[j][i] = dp[(j+1) % n][i-1]+dp[(j-1) % n][i-1]
print(dp[1][m-1])


''' # 设顺时针方向，从小赛算起为第0个人，共n-1个人
    # 设dp[i][j]表示经过j次传球，球到第i(i从0--n-1)个人的传花的种类数
    # 则dp[i][j] = dp[i-1][j-1]+dp[i+1][j-1]
    # 当i==0时，dp[0][j] = dp[1][j-1]+dp[n-1][j-1]
    # 当i==n-1时，dp[n-1][j] = dp[n-2][j-1]+dp[0][j-1]
'''


def drinkingGame():
    (n, m) = (int(x) for x in input().split())
    dp = [[0] * (m + 1) for _ in range(n)]  # n行m列
    # 初始化
    dp[0][0] = 1  # 第1个人传0次给自己，共传了0次，传送种类数：1次
    dp[n - 1][1] = 1  # 从第1个人传给第n个人，共传了1次，传送种类数：1次
    dp[1][1] = 1  # 从第1个人传给第2个人，共传了1次，传送种类数：1次

    # 因为传第j次依赖于第j-1次，所以要先把第j-1次的都算完再计算第j次的结果，所以传送次数j应在外层循环
    for j in range(1, m + 1):
        for i in range(n):
            if i == 0:
                dp[0][j] = dp[1][j - 1] + dp[n - 1][j - 1]
            if i == n - 1:
                dp[n - 1][j] = dp[n - 2][j - 1] + dp[0][j - 1]
            else:
                dp[i][j] = dp[i - 1][j - 1] + dp[i + 1][j - 1]
    print(dp[0][m])             # 最终又到小塞第0号人的手里，共传m次

